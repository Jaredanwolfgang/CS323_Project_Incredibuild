use spl_lexer::tokens::{Token, LexicalError, Span};
use spl_ast::tree;
use lalrpop_util::ErrorRecovery;
use lalrpop_util::ParseError;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>, source: &str);

pub Program: tree::Program = {
    <prg:ProgramPart*> => {
        tree::Program::Program(
            prg
        )
    }
}

ProgramPart: tree::ProgramPart = {
    <stmt: Stmt> => tree::ProgramPart::Statement(Box::new(stmt)),
    <func: FuncDec> => tree::ProgramPart::Function(func)
}

// Some useful declarations in the beginning of the program
pub ParaDecs = Comma<ParaDec>;
StructDecs = Comma<StructDec>;
ArrayDecs = Comma<CompExpr>;

Comma<T>: Vec<T> = {
    <l:@L> <mut v:Comma<T>> "," <e:T?> <r:@R> => match e {
        None => {
            if v.len() != 0 {
                let error = ErrorRecovery {
                    error: ParseError::User {
                        error: LexicalError::MissingLexeme(Span {
                            source: source.to_string(),
                            start: l,
                            end: r
                        }, "variable".to_string())
                    },
                    dropped_tokens: Vec::new(),
                };
                errors.push(error);
            }
            v
        },
        Some(e) => {
            v.push(e);
            v
        }
    },
    <e:T> => vec![e],
};

ArgList: Vec<Box<tree::CompExpr>> = {
    <e:CompExpr> => vec![e],
    <l:@L> <mut v:ArgList> "," <e:CompExpr> <r:@R> => {
        v.push(e);
        v
    },

    // Error handling
    ArgList "," <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                }, "arguments".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Vec::new()
    }
}

VarDecs: Vec<tree::Variable> = {
    <l:@L> <mut v:VarDecs> "," <e:VarDec> <r:@R> => {
        v.push(e);
        v
    },
    <e:VarDec> => vec![e],

    // Error handling
    VarDecs "," <l:@L> ! <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                }, "variable name".to_string())
            }, dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Vec::new()
    },
}

ParaDec: tree::Variable = {
    <l:@L> <missing:!> Identifier? <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                }, "specifier".to_string())
            },
            dropped_tokens: Vec::new(), // or specify the dropped tokens
        };
        errors.push(error);
        tree::Variable::Error
    },
    <l:@L> <spec:Specifier> <name:Identifier?> <r:@R> => {
        let name = if let Some(n) = name {
            n
        } else {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l,
                        end: r
                    }, "variable name".to_string())
                },
                dropped_tokens: Vec::new(), // or specify the dropped tokens
            };
            errors.push(error);
            "INVALID".to_string()
        };
        tree::Variable::FormalParameter(
            Box::new(name),
            Box::new(spec),
            Box::new(Vec::new())
        )
    },
}

DimDecs: Vec<tree::CompExpr> = {
    "[" <n:CompExpr> "]" => {
        let mut v = Vec::new();
        v.push(*n);
        v
    },
    "[" <n:CompExpr> "]" <size:DimDecs> => {
        let mut v = Vec::new();
        v.push(*n);
        v.extend(size);
        v
    },

    // Error handling
    "[" CompExpr <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "closing bracket ']'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Vec::new()
    },
}

/*
* Statements
* 1. Struct definition: struct identifier { fields };
* 2. Include statement: include "string";
* 3. Global variable declaration: Specifier VarDec;
* 4. TODO: macro definition 
*/
pub Stmt: tree::Statement = {
    "struct" <name:Identifier> "{" <vl:@L> <fields:FieldsDec> <vr:@R> "}" <l:@L> <semicolon:";"?> <r:@R> => {
        if semicolon == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l,
                        end: l + 1
                    }, "semicolon ';'".to_string())
                },
                dropped_tokens: Vec::new(),
            };
            errors.push(error);
        }
        tree::Statement::Struct(
            tree::Variable::StructDefinition(
                Box::new(name),
                Box::new(fields)
            ),
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
    "include" <l:@L>  <name:"string"> <r:@R> => {
        tree::Statement::Include(
            Box::new(name),
            Span {
                source: source.to_string(),
                start: l,
                end: r
            }
        )
    },
    <l:@L> <spec:Specifier> <var: VarDecs> ";" <r:@R> => {
        let mut variables = Vec::new();
        let str_ = if let tree::Value::Struct(ref s) = spec { s.clone() } else { "".to_string() };
        var.iter().for_each(|x| {
            match x {
                tree::Variable::VarDeclaration(name, value, size) => {
                    if spec == tree::Value::Struct(str_.clone()) {
                        variables.push(tree::Variable::StructDeclaration(
                            Box::new(str_.clone()),
                            name.clone(),
                            size.to_owned()
                        ));
                    } else {
                        variables.push(tree::Variable::VarDeclaration(
                            name.clone(), 
                            Box::new(spec.to_owned()), 
                            size.clone()
                        ));
                    }
                },
                tree::Variable::VarAssignment(variable, value) => {
                    match variable.as_ref() {
                        tree::Variable::VarReference(name, size) => {
                            if spec != tree::Value::Struct(str_.clone()) {
                                variables.push(tree::Variable::VarAssignment(
                                    Box::new(tree::Variable::VarDeclaration(
                                        name.clone(), 
                                        Box::new(spec.to_owned()), 
                                        size.clone()
                                    )),
                                    value.clone()
                                ));
                            }
                        },
                        _ => {
                            let error = ErrorRecovery {
                                error: ParseError::User {
                                    error: LexicalError::StatementError(Span {
                                        source: source.to_string(),
                                        start: 0,
                                        end: 0
                                    }, "Invalid variable assignment".to_string())
                                },
                                dropped_tokens: Vec::new(),
                            };
                            errors.push(error);
                        }
                    };
                },
                _ => {}
            }
        });
        tree::Statement::GlobalVariable(variables, Span {
            source: source.to_string(),
            start: l,
            end: r
        })
    },
    <l:@L> <missing:!> <r:@R> ";" => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                }, "specifier".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Statement::Error
    }
}

/*
* Fields declaration: Used in struct definition 
*/
FieldsDec: Vec<tree::Variable> = {
    <field:VarDef> <l:@L> <semicolon:";"?> <r:@R> => {
        if semicolon == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l,
                        end: l + 1
                    }, "semicolon ';'".to_string())
                },
                dropped_tokens: Vec::new(), // or specify the dropped tokens
            };
            errors.push(error);
        }
        field
    },
    <mut fields:FieldsDec> <v:VarDef> <l:@L> <semicolon:";"?> <r:@R> => {
        if semicolon == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l,
                        end: l + 1
                    }, "semicolon ';'".to_string())
                },
                dropped_tokens: Vec::new(), // or specify the dropped tokens
            };
            errors.push(error);
        }
        fields.extend(v);
        fields
    },
}

/*
* Function declaration:
* 1. Function declaration: Specifier identifier (ParaDecs) { Body }
* 2. Function call: identifier (ArgList);
* 3. Body: { Expr* }
*/
pub FuncDec: Box<tree::Function> = {
    <ret: Specifier> <name:Identifier> <lb:"("> <params:ParaDecs?> <l:@L> <rb:")"?> <r:@R> "{" <body:Body> "}" => {
        if rb == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l,
                        end: r + 1
                    }, "closing parenthesis ')'".to_string())
                },
                dropped_tokens: Vec::new(),
            };
            errors.push(error);
            Box::new(tree::Function::Error)
        } else {
            Box::new(tree::Function::FuncDeclaration(
                Box::new(name),
                params.unwrap_or(Vec::new()),
                Box::new(ret),
                body
            ))
        }
    },
    <ret: Specifier> <name:Identifier> <lb:"("> <params:ParaDecs?> <l:@L> <rb:")"?> <r:@R> "{" <body:Body> ! <vr:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: vr,
                    end: vr + 1
                }, "closing brace '}'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::Function::Error)
    },
    <ret: Specifier> <name:Identifier> <lb:"("> <params:ParaDecs?> <l:@L> <rb:")"?> <r:@R> "{" <body:Body> <vl:@L> ! <vr:@R> "{" Expr+ "}" "}" => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::StatementError(Span {
                    source: source.to_string(),
                    start: vl,
                    end: vr + 1
                }, "No 'if' before 'else'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::Function::Error)
    },
}

FuncCall: tree::Expr = {
    <vl:@L> <name:Identifier> "(" <args:ArgList?> ")" ";" <vr:@R>=> {
        tree::Expr::FuncCall(
            tree::Function::FuncReference(
                Box::new(name),
                args.unwrap_or(Vec::new())
            ),
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
    <name:Identifier> "(" ArgList? <el:@L> ! ";" => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: el,
                    end: el + 1,
                }, "closing parenthesis ')'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
}

/*
* Body is a list of expressions
* Expressions can be:
* 1. If statement: if (CondExpr) { Body } else { Body }
* 2. While loop: while (CondExpr) { Body }
* 3. For loop: for (VarManagement; CondExpr; VarManagement) { Body }
* 4. Variable management: VarManagement;
* 5. Function call: FuncCall;
* 6. Break statement: break;
* 7. Continue statement: continue;
* 8. Return statement: return CompExpr;
*/

pub Body: tree::Body = {
    <stmt:Expr*> => tree::Body::Body(stmt)
}

Expr: tree::Expr = {
    <expr:OpenExpr> => expr,
    <expr:CloseExpr> => expr,
}

OpenExpr: tree::Expr = {
    "if" <vl:@L> "(" <l:@L> <cond:CondExpr?> ")" <vr:@R> <body:Expr> <vd:@R> => {
        let cond = match cond {
            Some(cond) => cond,
            None => {
                let error = ErrorRecovery {
                    error: ParseError::User {
                        error: LexicalError::MissingLexeme(Span {
                            source: source.to_string(),
                            start: l - 1,
                            end: l + 1
                        }, "condition".to_string())
                    },
                    dropped_tokens: Vec::new(),
                };
                errors.push(error);
                Box::new(tree::CondExpr::Bool(false))
            }
        };
        let body = match body {
            tree::Expr::Body(body, _) => body,
            _ => tree::Body::Body(vec![body])
        };
        tree::Expr::If(
            tree::If::IfExpr(cond, body),
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
    "if" <vl:@L> "(" <cond:CondExpr> <l:@L> <rb:")"> <r:@R> <v1l:@L> <body:CloseExpr> <v1r:@R> "else" <v2l:@L> <body_2:OpenExpr> <v2r:@R> => {
        let body = match body {
            tree::Expr::Body(body, _) => body,
            _ => tree::Body::Body(vec![body])
        };
        let body_2 = match body_2 {
            tree::Expr::Body(body, _) => body,
            _ => tree::Body::Body(vec![body_2])
        };
        tree::Expr::If(
            tree::If::IfElseExpr(
                cond,
                body,
                body_2
            ),
            Span {
                source: source.to_string(),
                start: vl,
                end: r
            }
        )
    },

    // if ( error ) { ... }
    "if" "(" <l:@L> <cond:CompExpr> ")" <body:Expr> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::StatementError(Span {
                    source: source.to_string(),
                    start: l - 1,
                    end: l + 1
                }, "Must be condition".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
    // if error Condition ) { ... }
    "if" <l:@L> ! <r:@R> CondExpr ")" Expr => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                }, "opening parenthesis '('".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },

    "if" "(" <l:@L> <cond:CondExpr?> <m:@L> ! <r:@R> Expr => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: m,
                    end: r
                }, "closing parenthesis ')'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },

    "if" <l:@L> ! <r:@R> <cond:CondExpr> ")" <body:CloseExpr> "else" <body_2:OpenExpr> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "opening parenthesis '('".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },

    "if" "(" <cond:CondExpr> <l:@L> ! <r:@R> <body:CloseExpr> "else" <body_2:OpenExpr> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "closing parenthesis ')'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
}

CloseExpr: tree::Expr = {
    "if" <vl:@L> "(" <cond:CondExpr> ")" <vr:@R> <v1l:@L> <body:CloseExpr> <v1r:@R> "else" <v2l:@L> <body_2:CloseExpr> <v2r:@R>  => {
        let body = match body {
            tree::Expr::Body(body, _) => body,
            _ => tree::Body::Body(vec![body])
        };
        let body_2 = match body_2 {
            tree::Expr::Body(body, _) => body,
            _ => tree::Body::Body(vec![body_2])
        };
        tree::Expr::If(
            tree::If::IfElseExpr(
                cond,
                body,
                body_2
            ),
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
    <expr:WhileExpr> => expr,
    <expr:ForExpr> => expr,
    <expr:FuncCall> => expr,
    <expr:VarManagement> ";" => expr,
    <l:@L> <expr:"break"> ";" => tree::Expr::Break(Span {
        source: source.to_string(),
        start: l,
        end: l + 1
    }),
    <l:@L> <expr:"continue"> ";" => tree::Expr::Continue(Span {
        source: source.to_string(),
        start: l,
        end: l + 1
    }),
    <l:@L> <expr:"return"> <val:CompExpr?> ";" => match val {
        None => tree::Expr::Return(tree::CompExpr::Value(tree::Value::Null), Span {
            source: source.to_string(),
            start: l,
            end: l + 1
        }),
        Some(val) => tree::Expr::Return(*val, Span {
            source: source.to_string(),
            start: l,
            end: l + 1
        })
    },
    "{" <vl:@L> <expr:Body> <vr:@R> "}" => tree::Expr::Body(expr, Span {
        source: source.to_string(),
        start: vl,
        end: vr
    }),

    // Error handling
    <expr:VarManagement> <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "semicolon ';'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
    <expr:"break"> <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "semicolon ';'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
    <expr:"continue"> <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "semicolon ';'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
    <expr:"return"> <val:CompExpr?> <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "semicolon ';'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
}

WhileExpr: tree::Expr = {
    "while" <l:@L> ! <r:@R> CondExpr ")" "{" Body "}" => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                }, "opening parenthesis '('".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Expr::Error
    },
    "while" <vl:@L>"(" <cond:CondExpr> <l:@L> <rb:")"?> <r:@R> "{" <body:Body> "}" => {
        if rb == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l,
                        end: l + 1
                    }, "closing parenthesis ')'".to_string())
                },
                dropped_tokens: Vec::new(),
            };
            errors.push(error);
        }
        tree::Expr::Loop(
            tree::Loop::WhileExpr(
                cond,
                body
            ),
            Span {
                source: source.to_string(),
                start: vl,
                end: r
            }
        )
    }
}

ForExpr: tree::Expr = {
    "for" <vl:@L> "(" <init:VarManagement?> ";" <cond:CondExpr?> ";" <update:VarManagement?> ")" <vr:@R> "{" <body:Body> "}" => {
        tree::Expr::Loop(
            tree::Loop::ForExpr(
                init.map(Box::new).unwrap_or(Box::new(
                    tree::Expr::VarManagement(
                        Vec::new(),
                        Span {
                        source: source.to_string(),
                        start: vl,
                        end: vl + 1
                    }
                ))),
                cond.unwrap_or(Box::new(tree::CondExpr::Bool(true))),
                update.map(Box::new).unwrap_or(Box::new(
                    tree::Expr::VarManagement(
                        Vec::new(),
                        Span {
                        source: source.to_string(),
                        start: vr - 1,
                        end: vr
                    }
                ))),
                body
            ),
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
}

StructRef: Vec<tree::Variable> = {
    <mut v:StructRef> "." <l:@L> <field:Identifier?> <r:@R> <dims:DimDecs?> => {
        if field == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l - 1,
                        end: l
                    }, "field name".to_string())
                },
                dropped_tokens: Vec::new(),
            };
            errors.push(error);
            return Vec::new();
        }
        let last = v.last().unwrap().clone();
        v.push(tree::Variable::VarReference(
            Box::new(field.unwrap()),
            Box::new(dims.unwrap_or(Vec::new()))
        ));
        v
    },
    <parent:Identifier> <parent_dims: DimDecs?> "." <l:@L> <field:Identifier?> <r:@R> <dims:DimDecs?> => {
        if field == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(Span {
                        source: source.to_string(),
                        start: l - 1,
                        end: r
                    }, "field name".to_string())
                },
                dropped_tokens: Vec::new(),
            };
            errors.push(error);
            return Vec::new();
        }
        vec![tree::Variable::VarReference(
            Box::new(parent.clone()),
            Box::new(parent_dims.unwrap_or(Vec::new()))
        ), tree::Variable::VarReference(
            Box::new(field.unwrap()),
            Box::new(dims.unwrap_or(Vec::new()))
        )]
    },
}

VarManagement: tree::Expr = {
    /* Four types of assignment:
     * 1. Variable declaration: Specifier VarDecs;
     * 2. identifier = CompExpr;
     * 3. identifier++;
     * 4. identifier--;
    */
    <vl:@L> <def: VarDef> <vr:@R> => {
        tree::Expr::VarManagement(
            def,
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
    <vl:@L> <def: VarDec> <vr:@R> => {
        tree::Expr::VarManagement(
            vec![def],
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
    <vl:@L> <lhs:Identifier> <dims:DimDecs?> "++" <vr:@R> => {
        let dims = match dims {
            Some(dims) => dims,
            None => Vec::new()
        };
        tree::Expr::VarManagement(
            vec![tree::Variable::VarAssignment(
                Box::new(tree::Variable::VarReference(Box::new(lhs.clone()), Box::new(dims.clone()))),
                Box::new(vec![tree::CompExpr::BinaryOperation(
                    Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(lhs.clone()), Box::new(dims.clone())))),
                    tree::BinaryOperator::Add,
                    Box::new(tree::CompExpr::Value(tree::Value::Integer(1)))
                )]),
            )],
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
    <vl:@L> <lhs:Identifier> <dims:DimDecs?> "--" <vr:@R> => {
        let dims = match dims {
            Some(dims) => dims,
            None => Vec::new()
        };
        tree::Expr::VarManagement(
            vec![tree::Variable::VarAssignment(
                Box::new(tree::Variable::VarReference(Box::new(lhs.clone()), Box::new(dims.clone()))),
                Box::new(vec![tree::CompExpr::BinaryOperation(
                    Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(lhs.clone()), Box::new(dims.clone())))),
                    tree::BinaryOperator::Sub,
                    Box::new(tree::CompExpr::Value(tree::Value::Integer(1)))
                )]),
            )],
            Span {
                source: source.to_string(),
                start: vl,
                end: vr
            }
        )
    },
}

// Variable Definition is composed of: specifier, variable declaration;
// You should be able to declare multiple variables at once
// However, some varaibles is declared with initial value, then it should be treated as assignment
VarDef: Vec<tree::Variable> = {
    <spec:Specifier> <name:Identifier> <dim: DimDecs?> "=" "{" <fields:StructDecs> "}"=> {
        let mut variables = Vec::new();
        let str = if let tree::Value::Struct(s) = spec {
            s
        } else {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::StatementError(Span {
                        source: source.to_string(),
                        start: 0,
                        end: 0
                    }, "Invalid struct specifier".to_string())
                },
                dropped_tokens: Vec::new(),
            };
            errors.push(error);
            return Vec::new();
        };
        variables.push(tree::Variable::StructDeclaration(
            Box::new(str),
            Box::new(name.clone()),
            Box::new(dim.clone().unwrap_or(Vec::new()))
        ));
        for field in fields {
            match field {
                tree::Variable::VarAssignment(mem, value) => {
                    let mut member = vec![tree::Variable::VarReference(Box::new(name.clone()), Box::new(dim.clone().unwrap_or(Vec::new())))];
                    member.push(*mem);
                    variables.push(tree::Variable::VarAssignment(
                        Box::new(tree::Variable::StructReference(Box::new(member))),
                        value,
                    ));
                },
                _ => {}
            }
        }
        variables
    },
    <spec:Specifier> <var: VarDecs> => {
        let mut variables = Vec::new();
        let str_ = if let tree::Value::Struct(ref s) = spec { s.clone() } else { "".to_string() };
        var.iter().for_each(|x| {
            match x {
                tree::Variable::VarDeclaration(name, value, size) => {
                    if spec == tree::Value::Struct(str_.clone()) {
                        variables.push(tree::Variable::StructDeclaration(
                            Box::new(str_.clone()),
                            name.clone(),
                            size.to_owned()
                        ));
                    } else {
                        variables.push(tree::Variable::VarDeclaration(
                            name.clone(), 
                            Box::new(spec.to_owned()), 
                            size.clone()
                        ));
                    }
                },
                tree::Variable::VarAssignment(variable, value) => {
                    match variable.as_ref() {
                        tree::Variable::VarReference(name, size) => {
                            if spec != tree::Value::Struct(str_.clone()) {
                                variables.push(tree::Variable::VarDeclaration(
                                    name.clone(), 
                                    Box::new(spec.to_owned()), 
                                    size.clone()
                                ));
                                variables.push(tree::Variable::VarAssignment(
                                    Box::new(tree::Variable::VarReference(name.clone(), Box::new(Vec::new()))),
                                    value.clone()
                                ));
                            }
                        },
                        _ => {
                            let error = ErrorRecovery {
                                error: ParseError::User {
                                    error: LexicalError::StatementError(Span {
                                        source: source.to_string(),
                                        start: 0,
                                        end: 0
                                    }, "Invalid variable assignment".to_string())
                                },
                                dropped_tokens: Vec::new(),
                            };
                            errors.push(error);
                        }
                    };
                },
                _ => {}
            }
        });
        variables
    },
}

// Variable Declaration
// 1. identifier; => specifier ident;
// 2. identifier[size][size]...; => specifier ident[size][size]...;
// 3. identifier = CompExpr; => specifier ident = CompExpr;
VarDec: tree::Variable = {
    <ident: Identifier> <dims: DimDecs?> => {
        tree::Variable::VarDeclaration(
            Box::new(ident),
            Box::new(tree::Value::Null),
            Box::new(dims.unwrap_or(Vec::new()))
        )
    },
    <ident: Identifier> <size: DimDecs?> "=" <val:CompExpr> => {
        tree::Variable::VarAssignment(
            Box::new(tree::Variable::VarReference(Box::new(ident), Box::new(size.unwrap_or(Vec::new())))),
            Box::new(vec![*val]),
        )
    },
    <s:StructRef> "=" <val:CompExpr> => {
        tree::Variable::VarAssignment(
            Box::new(tree::Variable::StructReference(Box::new(s))),
            Box::new(vec![*val])
        )
    },
    <ident: Identifier> <size: DimDecs?> "=" "{" <val: ArrayDecs> "}" => {
        tree::Variable::VarAssignment(
            Box::new(tree::Variable::VarReference(Box::new(ident), Box::new(size.unwrap_or(Vec::new())))),
            Box::new(val.into_iter().map(|x| *x).collect()),
        )
    },

    // Error handling
    <l:@L> "=" <r:@R> CompExpr => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "left value".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Variable::Error
    },
    <ident: Identifier> <size: DimDecs?> "=" <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "right value".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        tree::Variable::Error
    },
}

StructDec: tree::Variable = {
    "." <ident: Identifier> ":" <val: CompExpr> => {
        tree::Variable::VarAssignment(
            Box::new(tree::Variable::VarReference(Box::new(ident), Box::new(Vec::new()))),
            Box::new(vec![*val]),
        )
    },
    ! => { errors.push(<>); tree::Variable::Error },
}


pub CondExpr: Box<tree::CondExpr> = {
#[precedence(level="1")]
    CondTerm,
    "!" <expr:CondExpr> => {
        Box::new(tree::CondExpr::UnaryCondition(
            tree::UnaryOperator::Not, expr
        ))
    },
#[precedence(level="2")]
    <lhs:CompExpr> ">" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::GT, rhs
        ))
    },
    <lhs:CompExpr> "<" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::LT, rhs
        ))
    },
    <lhs:CompExpr> ">=" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::GE, rhs
        ))
    },
    <lhs:CompExpr> "<=" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::LE, rhs
        ))
    },
    <lhs:CompExpr> "==" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::EQ, rhs
        ))
    },
    <lhs:CompExpr> "!=" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::NE, rhs
        ))
    },
#[precedence(level="3")] #[assoc(side="left")]
    <lhs:CondExpr> "&&" <rhs:CondExpr> => {
        Box::new(tree::CondExpr::BinaryCondition(
            lhs, tree::BinaryOperator::And, rhs
        ))
    },
    <lhs:CondExpr> "||" <rhs:CondExpr> => {
        Box::new(tree::CondExpr::BinaryCondition(
            lhs, tree::BinaryOperator::Or, rhs
        ))
    },
}

pub CompExpr: Box<tree::CompExpr> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")] #[assoc(side="left")]
    CompExpr <l:@L> <error: "error"> <r:@R> CompExpr => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::UnknownLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                })
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },

    CompExpr "%" <l:@L> ! <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after %".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "%" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Mod, rhs
        ))
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:CompExpr> "*" <l:@L> <rhs:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after *".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "*" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Mul, rhs
        ))
    },

    <lhs:CompExpr> "/" <l:@L> <rhs:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after /".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "/" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Div, rhs
        ))
    },

    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:CompExpr> "+" <l:@L> <rhs:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after +".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "+" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Add, rhs
        ))
    },

    <lhs:CompExpr> "-" <l:@L> <rhs:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after -".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "-" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Sub, rhs
        ))
    },

    #[precedence(level="5")] #[assoc(side="left")]
    CompExpr "&" <l:@L> <rhs:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after &".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "&" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::BitwiseAnd, rhs
        ))
    },

    CompExpr "|" <l:@L> <rhs:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after |".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "|" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::BitwiseOr, rhs
        ))
    },

    CompExpr "^" <l:@L> ! <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "Exp after ^".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    <l:@L> <lhs:CompExpr> "^" <rhs:CompExpr> <r:@R> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::BitwiseXor, rhs
        ))
    },
}

Specifier: tree::Value = {
    <t:"typeint"> => tree::Value::Integer(0),
    <t:"typeint"> "*" => tree::Value::Pointer(Box::new(tree::Value::Integer(0))),
    <t:"typefloat"> => tree::Value::Float(0.0),
    <t:"typefloat"> "*" => tree::Value::Pointer(Box::new(tree::Value::Float(0.0))),
    <t:"typechar"> => tree::Value::Char(' '),
    <t:"typechar"> "*" => tree::Value::Pointer(Box::new(tree::Value::Char(' '))),
    <t:"typestr"> => tree::Value::String(String::new()),
    <t:"void"> => tree::Value::Null,
    "struct" <str: Identifier> => tree::Value::Struct(str)
}

Term: Box<tree::CompExpr> = {
    "(" <CompExpr> ")",
    "(" <e:CompExpr> <l:@L> ! <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "closing parenthesis ')'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::MissingRP)
    },
    <n: Identifier> <dims:DimDecs?> => {
        match dims {
            Some(dims) => Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(n), Box::new(dims)))),
            None => Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(n), Box::new(Vec::new())))),
        }
    },
    "+"? <n: "int"> => Box::new(tree::CompExpr::Value(tree::Value::Integer(n))),
    "-"  <n: "int"> => Box::new(tree::CompExpr::BinaryOperation(
        Box::new(tree::CompExpr::Value(tree::Value::Integer(0))),
        tree::BinaryOperator::Sub,
        Box::new(tree::CompExpr::Value(tree::Value::Integer(n)))
    )),
    "+"? <n: "float"> => Box::new(tree::CompExpr::Value(tree::Value::Float(n))),
    "-"  <n: "float"> => Box::new(tree::CompExpr::Value(tree::Value::Float(-n))),
    <n: "char"> => Box::new(tree::CompExpr::Value(tree::Value::Char(n))),
    <n: "string"> => Box::new(tree::CompExpr::Value(tree::Value::String(n))),
    <vl:@L> <ident: Identifier> "(" <args:ArgList?> ")" <vr:@R>=> {
        Box::new(tree::CompExpr::FuncCall(
            tree::Function::FuncReference(Box::new(ident), args.unwrap_or(Vec::new()))
        ))
    },
    <s:StructRef> => {
        Box::new(tree::CompExpr::Variable(tree::Variable::StructReference(Box::new(s))))
    },
    "&" <ident:Identifier> => {
        Box::new(tree::CompExpr::UnaryOperation(
            tree::UnaryOperator::Ref,
            Box::new(
                tree::CompExpr::Variable(
                    tree::Variable::VarReference(
                        Box::new(ident), 
                        Box::new(Vec::new())
                    )
                )
            )
        ))
    },
    "*" <ident:Identifier> => {
        Box::new(tree::CompExpr::UnaryOperation(
            tree::UnaryOperator::Deref,
            Box::new(
                tree::CompExpr::Variable(
                    tree::Variable::VarReference(
                        Box::new(ident), 
                        Box::new(Vec::new())
                    )
                ),
            )
        ))
    },
    // error recovery
    <ident: Identifier> "(" ArgList? <l:@L> <missing:!> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::MissingLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: l + 1
                }, "closing parenthesis ')'".to_string())
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::MissingRP)
    },
    <l:@L> <error: "error"> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::UnknownLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                })
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Invalid)
    },
}

CondTerm: Box<tree::CondExpr> = {
    <n: "bool"> => Box::new(tree::CondExpr::Bool(n)),
    "(" <CondExpr> ")",
}

Identifier: String = {
    "identifier",
    <l:@L> "invalid" <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::UnknownLexeme(Span {
                    source: source.to_string(),
                    start: l,
                    end: r
                })
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        "INVALID".to_string()
    }
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "identifier" => Token::Identifier(<String>),
        "int" => Token::LiteralInt(<u32>),
        "float" => Token::LiteralFloat(<f32>),
        "bool" => Token::LiteralBool(<bool>),
        "char" => Token::LiteralChar(<char>),
        "string" => Token::LiteralString(<String>),
        "typeint" => Token::TypeInt,
        "typefloat" => Token::TypeFloat,
        "typechar" => Token::TypeChar,
        "typestr" => Token::TypeString,
        "void" => Token::TypeVoid,
        "null" => Token::TypeNull,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "{" => Token::LeftBrace,
        "}" => Token::RightBrace,
        "[" => Token::LeftBracket,
        "]" => Token::RightBracket,
        "." => Token::Dot,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "+" => Token::OpPlus,
        "-" => Token::OpMinus,
        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "^" => Token::OpXor,
        "%" => Token::OpMod,
        ">" => Token::OpGreaterThan,
        "<" => Token::OpLessThan,
        ">=" => Token::OpGreaterThanEqual,
        "<=" => Token::OpLessThanEqual,
        "==" => Token::OpEqual,
        "!=" => Token::OpNotEqual,
        "&&" => Token::OpAnd,
        "||" => Token::OpOr,
        "!" => Token::OpNot,
        "=" => Token::OpAssign,
        "++" => Token::OpIncrement,
        "--" => Token::OpDecrement,
        "&" => Token::OpBitwiseAnd,
        "|" => Token::OpBitwiseOr,
        "if" => Token::KeywordIf,
        "else" => Token::KeywordElse,
        "while" => Token::KeywordWhile,
        "for" => Token::KeywordFor,
        "return" => Token::KeywordReturn,
        "break" => Token::KeywordBreak,
        "continue" => Token::KeywordContinue,
        "enum" => Token::DeclarationEnum,
        "struct" => Token::DeclarationStruct,
        "include" => Token::DeclarationInclude,
        "invalid" => Token::Invalid,
        "error" => Token::Error,
    }
}
