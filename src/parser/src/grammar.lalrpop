use spl_lexer::tokens::{Token, LexicalError};
use spl_ast::tree;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "identifier" => Token::Identifier(<String>),
    "," => Token::Comma,
    "int" => Token::LiteralInt(<i32>),
    "float" => Token::LiteralFloat(<f32>),
    "bool" => Token::LiteralBool(<bool>),
    "char" => Token::LiteralChar(<char>),
    "typeint" => Token::TypeInt,
    "typefloat" => Token::TypeFloat,
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "+" => Token::OpPlus,
    "-" => Token::OpMinus,
    "*" => Token::OpMul,
    "/" => Token::OpDiv,
    "^" => Token::OpPow,
    "%" => Token::OpMod,
  }
}

// pub Program: Program = {
//     <prg:ProgramPart*> => prg
// }

// ProgramPart: tree::Program = {
// 
// }

pub ParaDecs = Comma<ParaDec>;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

ParaDec: Box<tree::Variable> = {
    <spec:Specifier> <name:"identifier"> => {
        let mut values = Vec::new();
        values.push(spec);
        Box::new(tree::Variable::FormalParameter(
            Box::new(name),
            Box::new(values),
            Box::new(Vec::new())
        ))
    }
}

Specifier: tree::Value = {
    <t:"typeint"> => tree::Value::Integer(0),
}

pub CompExpr: Box<tree::CompExpr> = {
#[precedence(level="1")]
    Term,

#[precedence(level="2")] #[assoc(side="left")]
    <lhs:CompExpr> "^" <rhs:CompExpr> => {
      Box::new(tree::CompExpr::BinaryOperation (
        lhs, tree::BinaryOperator::Pow, rhs
      ))
    },

    <lhs:CompExpr> "%" <rhs:CompExpr> => {
      Box::new(tree::CompExpr::BinaryOperation (
        lhs, tree::BinaryOperator::Mod, rhs
      ))
    },

#[precedence(level="3")] #[assoc(side="left")]
    <lhs:CompExpr> "*" <rhs:CompExpr> => {
      Box::new(tree::CompExpr::BinaryOperation (
        lhs, tree::BinaryOperator::Mul, rhs
      ))
    },

    <lhs:CompExpr> "/" <rhs:CompExpr> => {
      Box::new(tree::CompExpr::BinaryOperation (
        lhs, tree::BinaryOperator::Div, rhs
      ))
    },

#[precedence(level="4")] #[assoc(side="left")]
    <lhs:CompExpr> "+" <rhs:CompExpr> => {
      Box::new(tree::CompExpr::BinaryOperation (
        lhs, tree::BinaryOperator::Add, rhs
      ))
    },

    <lhs:CompExpr> "-" <rhs:CompExpr> => {
      Box::new(tree::CompExpr::BinaryOperation (
        lhs, tree::BinaryOperator::Sub, rhs
      ))
    },
}

Term: Box<tree::CompExpr> = {
    <n: "int"> => Box::new(tree::CompExpr::Value(tree::Value::Integer(n))),
    <n: "float"> => Box::new(tree::CompExpr::Value(tree::Value::Float(n))),
    <n: "bool"> => Box::new(tree::CompExpr::Value(tree::Value::Bool(n))),
    <n: "char"> => Box::new(tree::CompExpr::Value(tree::Value::Char(n))),
    "(" <CompExpr> ")",
    ! => { errors.push(<>); Box::new(tree::CompExpr::Error) },
}
