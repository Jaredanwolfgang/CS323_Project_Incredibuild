use spl_lexer::tokens::{Token, LexicalError};
use spl_ast::tree;
use lalrpop_util::ErrorRecovery;
use lalrpop_util::ParseError;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, LexicalError>>);

pub Program: tree::Program = {
    <prg:ProgramPart*> => {
        tree::Program::Program(
            prg
        )
    }
}

ProgramPart: tree::ProgramPart = {
    <stmt: Stmt> => tree::ProgramPart::Statement(Box::new(stmt)),
    <func: FuncDec> => tree::ProgramPart::Function(func)
}

// Some useful declarations in the beginning of the program
pub ParaDecs = Comma<ParaDec>;
ArgList = Comma<CompExpr>;
VarDecs = Comma<VarDec>;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

ParaDec: tree::Variable = {
    <spec:Specifier> <name:Identifier> => {
        tree::Variable::FormalParameter(
            Box::new(name),
            Box::new(spec),
            Box::new(Vec::new())
        )
    }
}

DimDecs: Vec<tree::CompExpr> = {
    "[" <n:CompExpr> "]" => {
        let mut v = Vec::new();
        v.push(*n);
        v
    },
    "[" <n:CompExpr> "]" <size:DimDecs> => {
        let mut v = Vec::new();
        v.push(*n);
        v.extend(size);
        v
    }
}

/*
* Statements
* 1. Struct definition: struct identifier { fields };
* 2. Include statement: include "string";
* 3. Global variable declaration: Specifier VarDec;
* 4. TODO: macro definition 
*/
pub Stmt: tree::Statement = {
    "struct" <name:Identifier> "{" <fields:FieldsDec> "}" ";" => {
        tree::Statement::Struct(
            tree::Variable::StructDefinition(
                Box::new(name),
                Box::new(fields)
            )
        )
    },
    "include" <name:"string"> ";" => {
        tree::Statement::Include(
            Box::new(name)
        )
    },
    <global: VarDef> ";"=> {
        tree::Statement::GlobalVariable(
            global
        )
    },

}

/*
* Fields declaration: Used in struct definition 
*/
FieldsDec: Vec<tree::Variable> = {
    <field:VarDef> <l:@L> <comma:";"?> <r:@R> => {
        if comma == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(l, "';'".to_string(), r)
                },
                dropped_tokens: Vec::new(), // or specify the dropped tokens
            };
            errors.push(error);
        }
        field
    },
    <mut fields:FieldsDec> <v:VarDef> ";" => {
        fields.extend(v);
        fields
    },
}

/*
* Function declaration:
* 1. Function declaration: Specifier identifier (ParaDecs) { Body }
* 2. Function call: identifier (ArgList);
* 3. Body: { Expr* }
*/
pub FuncDec: Box<tree::Function> = {
    <ret: Specifier> <name:Identifier> <l:@L> <lb:"("> <params:ParaDecs> <rb:")"?> <r:@R> "{" <body:Body> "}" => {
        if rb == None {
            let error = ErrorRecovery {
                error: ParseError::User {
                    error: LexicalError::MissingLexeme(l, "')'".to_string(), r)
                },
                dropped_tokens: Vec::new(), // or specify the dropped tokens
            };
            errors.push(error);
        }
        Box::new(tree::Function::FuncDeclaration(
            Box::new(name),
            params,
            Box::new(ret),
            body
        ))
    },
    ! => { errors.push(<>); Box::new(tree::Function::Error) },
}

FuncCall: tree::Expr = {
    <name:Identifier> "(" <args:ArgList> ")" ";" => {
        tree::Expr::FuncCall(
            tree::Function::FuncReference(
                Box::new(name),
                args
            )
        )
    }
}

/*
* Body is a list of expressions
* Expressions can be:
* 1. If statement: if (CondExpr) { Body } else { Body }
* 2. While loop: while (CondExpr) { Body }
* 3. For loop: for (VarManagement; CondExpr; VarManagement) { Body }
* 4. Variable management: VarManagement;
* 5. Function call: FuncCall;
* 6. Break statement: break;
* 7. Continue statement: continue;
* 8. Return statement: return CompExpr;
*/

pub Body: tree::Body = {
    <stmt:Expr*> => tree::Body::Body(stmt)
}

Expr: tree::Expr = {
    <expr:IfExpr> => expr,
    <expr:WhileExpr> => expr,
    <expr:ForExpr> => expr,
    <expr:FuncCall> => expr,
    <expr:VarManagement> ";" => expr,
    <expr:"break"> ";" => tree::Expr::Break,
    <expr:"continue"> ";" => tree::Expr::Continue,
    <expr:"return"> <val:CompExpr?> ";" => match val {
        None => tree::Expr::Return(tree::CompExpr::Value(tree::Value::Null)),
        Some(val) => tree::Expr::Return(*val)
    },
    "{" <expr:Body> "}" => tree::Expr::Body(expr),
    ! => {
        let error = <>;
        match &error.error {
            ParseError::UnrecognizedToken { token, expected } => {
                if expected.contains(&"\";\"".to_string()) {
                    let error = ErrorRecovery {
                        error: ParseError::User {
                            error: LexicalError::MissingLexeme(token.0, "';'".to_string(), token.2)
                        },
                        dropped_tokens: Vec::new(),
                    };
                    errors.push(error);
                }
            },
            _ => {}
        }
        tree::Expr::Error
    }
}

IfExpr: tree::Expr = {
    "if" "(" <cond:CondExpr> ")" <body:Expr>  => {
        match body {
            tree::Expr::Body(body) => {
                tree::Expr::If(
                    tree::If::IfExpr(
                        cond,
                        body
                    )
                )
            },
            _ => {
                tree::Expr::If(
                    tree::If::IfExpr(cond, tree::Body::Body(vec![body]))
                )
            }
        }
    },
    "if" "(" <cond:CondExpr> ")" "{" <body:Body> "}" "else" "{" <body_2:Body> "}" => {
        tree::Expr::If(
            tree::If::IfElseExpr(
                cond,
                body, 
                body_2
            )
        )
    }
}

WhileExpr: tree::Expr = {
    "while" "(" <cond:CondExpr> ")" "{" <body:Body> "}" => {
        tree::Expr::Loop(
            tree::Loop::WhileExpr(
                cond,
                body
            )
        )
    }
}

ForExpr: tree::Expr = {
    "for" "(" <init:VarManagement> ";" <cond:CondExpr> ";" <update:VarManagement> ")" "{" <body:Body> "}" => {
        tree::Expr::Loop(
            tree::Loop::ForExpr(
                Box::new(init),
                cond,
                Box::new(update),
                body
            )
        )
    }
}

VarManagement: tree::Expr = {
    /* Four types of assignment:
     * 1. Variable declaration: Specifier VarDecs;
     * 2. identifier = CompExpr;
     * 3. identifier++;
     * 4. identifier--;
    */
    #[precedence(level="1")]
    <def: VarDef> => {
        tree::Expr::VarManagement(
            def
        )
    },
    #[precedence(level="2")]
    <def: VarDec> => {
        tree::Expr::VarManagement(
            vec![def]
        )
    },
    <obj: Identifier> "." <field: Identifier> "=" <val:CompExpr> => {
        tree::Expr::VarManagement(
            vec![tree::Variable::StructAssignment(
                Box::new(obj.clone()),
                Box::new(field.clone()),
                val
            )]
        )
    },
    <lhs:Identifier> <dims:DimDecs?> "++" => {
        let dims = match dims {
            Some(dims) => dims,
            None => Vec::new()
        };
        tree::Expr::VarManagement(
            vec![tree::Variable::VarAssignment(
                Box::new(lhs.clone()),
                Box::new(tree::CompExpr::BinaryOperation(
                    Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(lhs.clone()), Box::new(dims)))),
                    tree::BinaryOperator::Add,
                    Box::new(tree::CompExpr::Value(tree::Value::Integer(1)))
                )),
                Box::new(Vec::new())
            )]
        )
    },
    <lhs:Identifier> <dims:DimDecs?> "--" => {
        let dims = match dims {
            Some(dims) => dims,
            None => Vec::new()
        };
        tree::Expr::VarManagement(
            vec![tree::Variable::VarAssignment(
                Box::new(lhs.clone()),
                Box::new(tree::CompExpr::BinaryOperation(
                    Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(lhs.clone()), Box::new(dims)))),
                    tree::BinaryOperator::Sub,
                    Box::new(tree::CompExpr::Value(tree::Value::Integer(1)))
                )),
                Box::new(Vec::new())
            )]
        )
    },
}

// Variable Definition is composed of: specifier, variable declaration;
// You should be able to declare multiple variables at once
// However, some varaibles is declared with initial value, then it should be treated as assignment
VarDef: Vec<tree::Variable> = {
    "struct" <str: Identifier> <name:Identifier> => {
        vec![tree::Variable::StructDeclaration(
            Box::new(str),
            Box::new(name),
            Box::new(Vec::new())
        )]
    },
    "struct" <str: Identifier> <name:Identifier> "{" <fields:StructDecs> "}"=> {
        vec![tree::Variable::StructDeclaration(
            Box::new(str),
            Box::new(name),
            Box::new(fields)
        )]
    },
    <spec: Specifier> <var: VarDecs> => {
        let mut variables = Vec::new();
        var.iter().for_each(|x| {
            match x {
                tree::Variable::VarDeclaration(name, value, size) => {
                    variables.push(tree::Variable::VarDeclaration(name.clone(), Box::new(spec.to_owned()), size.clone()));
                },
                tree::Variable::VarAssignment(name, value, dims) => {
                    variables.push(tree::Variable::VarDeclaration(name.clone(), Box::new(spec.to_owned()), Box::new(Vec::new())));
                    variables.push(tree::Variable::VarAssignment(name.clone(), value.to_owned(), dims.clone()));
                },
                _ => {}
            }
        });
        variables
    }
}

// Variable Declaration
// 1. identifier; => specifier ident;
// 2. identifier[size][size]...; => specifier ident[size][size]...;
// 3. identifier = CompExpr; => specifier ident = CompExpr;
VarDec: tree::Variable = {
    <ident: Identifier> <size: DimDecs?> => {
        let dims = match size {
            Some(dims) => dims,
            None => Vec::new()
        };
        tree::Variable::VarDeclaration(
            Box::new(ident),
            Box::new(tree::Value::Null),
            Box::new(dims)
        )
    },
    <ident: Identifier> <size: DimDecs?> "=" <val:CompExpr> => {
        let dims = match size {
            Some(dims) => dims,
            None => Vec::new()
        };
        tree::Variable::VarAssignment(
            Box::new(ident),
            val,
            Box::new(dims)
        )
    },
}

StructDecs = Comma<StructDec>;

StructDec: tree::Variable = {
    "." <ident: Identifier> ":" <val: CompExpr> => {
        tree::Variable::VarAssignment(
            Box::new(ident),
            val,
            Box::new(Vec::new())
        )
    },
    ! => { errors.push(<>); tree::Variable::Error },
}

pub CondExpr: Box<tree::CondExpr> = {
#[precedence(level="1")]
    CondTerm,
    "!" <expr:CondExpr> => {
        Box::new(tree::CondExpr::UnaryCondition(
            tree::UnaryOperator::Not, expr
        ))
    },
#[precedence(level="2")]
    <lhs:CompExpr> ">" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::GT, rhs
        ))
    },
    <lhs:CompExpr> "<" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::LT, rhs
        ))
    },
    <lhs:CompExpr> ">=" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::GE, rhs
        ))
    },
    <lhs:CompExpr> "<=" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::LE, rhs
        ))
    },
    <lhs:CompExpr> "==" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::EQ, rhs
        ))
    },
    <lhs:CompExpr> "!=" <rhs:CompExpr> => {
        Box::new(tree::CondExpr::Condition(
            lhs, tree::JudgeOperator::NE, rhs
        ))
    },
#[precedence(level="3")] #[assoc(side="left")] 
    <lhs:CondExpr> "&&" <rhs:CondExpr> => {
        Box::new(tree::CondExpr::BinaryCondition(
            lhs, tree::BinaryOperator::And, rhs
        ))
    },
    <lhs:CondExpr> "||" <rhs:CondExpr> => {
        Box::new(tree::CondExpr::BinaryCondition(
            lhs, tree::BinaryOperator::Or, rhs
        ))
    },
}

pub CompExpr: Box<tree::CompExpr> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")] #[assoc(side="left")]
    <lhs: CompExpr> <l:@L> <error: "error"> <r:@R> <rhs:CompExpr> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::UnknownLexeme(l, r)
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },

    <lhs:CompExpr> "^" <rhs:CompExpr> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Pow, rhs
        ))
    },

    <lhs:CompExpr> "%" <rhs:CompExpr> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Mod, rhs
        ))
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:CompExpr> "*" <rhs:CompExpr> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Mul, rhs
        ))
    },

    <lhs:CompExpr> "/" <rhs:CompExpr> => {
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Div, rhs
        ))
    },

    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:CompExpr?> "+" <rhs:CompExpr> => {
        let lhs = match lhs {
             Some(x) => x,
             None => Box::new(tree::CompExpr::Value(tree::Value::Integer(0)))
        };
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Add, rhs
        ))
    },

    <lhs:CompExpr?> "-" <rhs:CompExpr> => {
        let lhs = match lhs {
            Some(x) => x,
            None => Box::new(tree::CompExpr::Value(tree::Value::Integer(0)))
        };
        Box::new(tree::CompExpr::BinaryOperation (
            lhs, tree::BinaryOperator::Sub, rhs
        ))
    },
}

Specifier: tree::Value = {
    <t:"typeint"> => tree::Value::Integer(0),
    <t:"typefloat"> => tree::Value::Float(0.0),
    <t:"typechar"> => tree::Value::Char(' '),
    <t:"typestr"> => tree::Value::String(String::new()),
    <t:"void"> => tree::Value::Null,
}

Term: Box<tree::CompExpr> = {
    "(" <CompExpr> ")",
    <n: Identifier> <dims:DimDecs?> => {
        match dims {
            Some(dims) => Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(n), Box::new(dims)))),
            None => Box::new(tree::CompExpr::Variable(tree::Variable::VarReference(Box::new(n), Box::new(Vec::new())))),
        }
    },
    <n: "int"> => Box::new(tree::CompExpr::Value(tree::Value::Integer(n))),
    <n: "float"> => Box::new(tree::CompExpr::Value(tree::Value::Float(n))),
    <n: "char"> => Box::new(tree::CompExpr::Value(tree::Value::Char(n))),
    <ident: Identifier> "(" <args:ArgList> ")" => {
        Box::new(tree::CompExpr::FuncCall(
            tree::Function::FuncReference(Box::new(ident), args)
        ))
    },

    // error recovery
    <l:@L> <error: "error"> <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::UnknownLexeme(l, r)
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        Box::new(tree::CompExpr::Error)
    },
    ! => {
        let error = <>;
        match &error.error {
            ParseError::UnrecognizedToken { token, expected } => {
                let error = if expected.contains(&"\")\"".to_string()) {
                    ErrorRecovery {
                        error: ParseError::User {
                            error: LexicalError::MissingLexeme(token.0, "')'".to_string(), token.2)
                        },
                        dropped_tokens: Vec::new(),
                    }
                } else {
                    ErrorRecovery {
                        error: ParseError::User {
                            error: LexicalError::MissingLexeme(token.0, "Exp".to_string(), token.2)
                        },
                        dropped_tokens: Vec::new(),
                    }
                };
                errors.push(error);
            },
            _ => {}
        }
        Box::new(tree::CompExpr::Error)
    },
}

CondTerm: Box<tree::CondExpr> = {
    <n: "bool"> => Box::new(tree::CondExpr::Bool(n)),
    "(" <CondExpr> ")",
}

Identifier: String = {
    "identifier",
    <l:@L> "invalid" <r:@R> => {
        let error = ErrorRecovery {
            error: ParseError::User {
                error: LexicalError::UnknownLexeme(l, r)
            },
            dropped_tokens: Vec::new(),
        };
        errors.push(error);
        "INVALID".to_string()
    }
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "identifier" => Token::Identifier(<String>),
    
        "int" => Token::LiteralInt(<u32>),
        "float" => Token::LiteralFloat(<f32>),
        "bool" => Token::LiteralBool(<bool>),
        "char" => Token::LiteralChar(<char>),
        "string" => Token::LiteralString(<String>),
        "typeint" => Token::TypeInt,
        "typefloat" => Token::TypeFloat,
        "typechar" => Token::TypeChar,
        "typestr" => Token::TypeString,
        "void" => Token::TypeVoid,
        "null" => Token::TypeNull,

        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "{" => Token::LeftBrace,
        "}" => Token::RightBrace,
        "[" => Token::LeftBracket,
        "]" => Token::RightBracket,
        "." => Token::Dot,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        ":" => Token::Colon,

        "+" => Token::OpPlus,
        "-" => Token::OpMinus,
        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "^" => Token::OpPow,
        "%" => Token::OpMod,
        ">" => Token::OpGreaterThan,
        "<" => Token::OpLessThan,
        ">=" => Token::OpGreaterThanEqual,
        "<=" => Token::OpLessThanEqual,
        "==" => Token::OpEqual,
        "!=" => Token::OpNotEqual,
        "&&" => Token::OpAnd,
        "||" => Token::OpOr,
        "!" => Token::OpNot,
        "=" => Token::OpAssign,
        "++" => Token::OpIncrement,
        "--" => Token::OpDecrement,

        "if" => Token::KeywordIf,
        "else" => Token::KeywordElse,
        "while" => Token::KeywordWhile,
        "for" => Token::KeywordFor,
        "return" => Token::KeywordReturn,
        "break" => Token::KeywordBreak,
        "continue" => Token::KeywordContinue,

        "enum" => Token::DeclarationEnum,
        "struct" => Token::DeclarationStruct,
        "include" => Token::DeclarationInclude,

        "invalid" => Token::Invalid,
        "error" => Token::Error,
    }
}
